#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro
	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro
	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro
	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro
	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro
	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro
	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro
	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro
	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro
	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) erro#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS nametoidt;  						// map name to id

	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error("ERROR opening socket");

	setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));

	// type of socket created
	address.sin_family = AF_INET;
	address.sin_addr.s_addr = INADDR_ANY;
	address.sin_port = htons((unsigned short)atoi(argv[1]));

	if (bind(server_socket, (struct sockaddr*)&address, sizeof(address)) < 0)
		error("bind failed");

	// try to specify maximum of 5 backlog connections for the server socket
	if (listen(server_socket, 5) < 0) error("listen");

	addrlen = sizeof(address);
	puts("Waiting for connections ...");
}
#include "server.h"

void error(string msg) {
	perror(msg.c_str());
	exit(1);
}

int main(int argc, char* argv[]) {
	User user_info[MAXF];
	ifstream fp("user-info.txt");
	int i;
	for (i = 0; i < MAXF and fp >> user_info[i].name >> user_info[i].ip_address 
								>> user_info[i].port_no;i++) ;
	int CURF = i;
	int opt = 1;
	int server_socket, addrlen, new_socket, activity, valread, sd;
	mp_sidtoC client_info;  					// map socket id to Client details
	map<pair<string, int>, string> ipptoname;	// map ip address and port number to user name
	map<string, pair<string, int> > nametoipp;  // map user name to ip address and port number
	mp_ntoS netoidt;  						// map name to id
d
	int max_sd;
	struct sockaddr_in address;
	char buffer[1025];
	for (int i = 0; i < CURF; i++) {
		nametoipp.insert({user_info[i].name, {user_info[i].ip_address, user_info[i].port_no}});
		ipptoname.insert({{user_info[i].ip_address, user_info[i].port_no}, user_info[i].name});
	}
	fd_set readfds;
	if (argc != 2) {
		fprintf(stderr, "usage: %s <port>\n", argv[0]);
		exit(1);
	}
	struct timeval tv;  // time out for select.
	tv.tv_sec = ACTIVITY_TIMER;
	tv.tv_usec = 0;

	// create a server socket
	server_socket = socket(AF_INET, SOCK_STREAM, 0);
	if (server_socket < 0) error